import { assertArrayIncludes, assertEquals } from 'std/testing/asserts.ts';
import { describe, it } from 'std/testing/bdd.ts';
import { EmptyProviderStore } from '../../@providers/index.ts';
import { SupportedProviders } from '../../@providers/supported-providers.ts';
import { CloudEdge, CloudGraph, CloudNode } from '../../cloud-graph/index.ts';
import { Pipeline } from '../pipeline.ts';
import { PipelineStep } from '../step.ts';
import { StepAction, StepStatusState } from '../types.ts';

describe('Pipeline', () => {
  it('should add edges', () => {
    const pipeline = new Pipeline();
    pipeline.insertEdges(
      new CloudEdge({
        from: 'a',
        to: 'b',
      }),
    );

    assertEquals(pipeline.edges.length, 1);
    assertArrayIncludes(
      pipeline.edges,
      [
        new CloudEdge({
          from: 'a',
          to: 'b',
        }),
      ],
    );
  });

  it('should remove edge with both to and from values', () => {
    const pipeline = new Pipeline();
    pipeline.insertEdges(
      new CloudEdge({
        from: 'a',
        to: 'b',
      }),
    );
    pipeline.removeEdge({
      to: 'b',
      from: 'a',
    });

    assertEquals(pipeline.edges.length, 0);
  });

  it('should schedule new nodes for creation', async () => {
    // no-op uses hashes generated by providers to detect drift
    const providerStore = new EmptyProviderStore();
    providerStore.save(new SupportedProviders.docker('docker', {}, providerStore));

    const plannedPipeline = await Pipeline.plan({
      before: new Pipeline(),
      after: new CloudGraph({
        edges: [],
        nodes: [
          new CloudNode({
            name: 'test',
            inputs: {
              name: 'test',
              databaseSize: 'large',
              databaseType: 'postgres',
              databaseVersion: '15',
              region: 'region',
              type: 'databaseCluster',
              vpc: 'vpc',
              account: 'docker',
            },
          }),
        ],
      }),
    }, providerStore);

    assertEquals(plannedPipeline.steps.length, 1);
    assertEquals(plannedPipeline.steps[0].action, 'create');
  });

  it('should schedule old nodes for deletion', async () => {
    // no-op uses hashes generated by providers to detect drift
    const providerStore = new EmptyProviderStore();
    providerStore.save(new SupportedProviders.docker('docker', {}, providerStore));

    const previousPipeline = new Pipeline({
      steps: [
        new PipelineStep({
          name: 'test',
          action: 'create',
          type: 'databaseCluster',
          color: 'blue',
          status: {
            state: 'complete',
          },
          inputs: {
            name: 'test',
            databaseSize: 'large',
            databaseType: 'postgres',
            databaseVersion: '15',
            region: 'region',
            type: 'databaseCluster',
            vpc: 'vpc',
            account: 'docker',
          },
        }),
      ],
    });

    const plannedPipeline = await Pipeline.plan({
      before: previousPipeline,
      after: new CloudGraph(),
    }, providerStore);

    assertEquals(plannedPipeline.steps.length, 1);
    assertEquals(plannedPipeline.steps[0].action, 'delete');
  });

  it('should schedule old nodes for deletion after some failed in previous pipeline', async () => {
    const providerStore = new EmptyProviderStore();
    providerStore.save(new SupportedProviders.docker('docker', {}, providerStore));

    const previousPipeline = new Pipeline({
      steps: [
        new PipelineStep({
          name: 'test',
          action: 'delete',
          type: 'vpc',
          color: 'blue',
          status: {
            state: 'complete',
          },
          inputs: {
            type: 'vpc',
            name: 'foo',
            region: 'bar',
          },
        }),
        new PipelineStep({
          name: 'test-2',
          action: 'delete',
          type: 'vpc',
          color: 'blue',
          status: {
            state: 'error',
          },
          inputs: {
            type: 'vpc',
            name: 'foo2',
            region: 'bar',
          },
        }),
      ],
    });

    const plannedPipeline = await Pipeline.plan({
      before: previousPipeline,
      after: new CloudGraph(),
    }, providerStore);

    assertEquals(plannedPipeline.steps.length, 1);
    assertEquals(plannedPipeline.steps[0].action, 'delete');
    assertEquals(plannedPipeline.steps[0].name, 'test-2');
  });

  it('should delete a node that was previously created and errored', async () => {
    const providerStore = new EmptyProviderStore();
    providerStore.save(new SupportedProviders.docker('docker', {}, providerStore));

    const previousPipeline = new Pipeline({
      steps: [
        new PipelineStep({
          name: 'test',
          action: 'create',
          type: 'vpc',
          color: 'blue',
          status: {
            state: 'error',
          },
          inputs: {
            type: 'vpc',
            name: 'foo',
            region: 'bar',
          },
        }),
      ],
    });

    const plannedPipeline = await Pipeline.plan({
      before: previousPipeline,
      after: new CloudGraph(),
    }, providerStore);

    assertEquals(plannedPipeline.steps.length, 1);
    assertEquals(plannedPipeline.steps[0].action, 'delete');
  });

  it('should set leaf update step as no-op w/out changes', async () => {
    // no-op uses hashes generated by providers to detect drift
    const providerStore = new EmptyProviderStore();
    providerStore.save(new SupportedProviders.docker('docker', {}, providerStore));

    const previousStep = new PipelineStep({
      name: 'test',
      action: 'update',
      type: 'databaseCluster',
      color: 'blue',
      status: {
        state: 'complete',
      },
      inputs: {
        name: 'test',
        databaseSize: 'large',
        databaseType: 'postgres',
        databaseVersion: '15',
        region: 'region',
        type: 'databaseCluster',
        vpc: 'vpc',
        account: 'docker',
      },
    });

    const previousPipeline = new Pipeline({ steps: [previousStep] });
    const plannedPipeline = await Pipeline.plan({
      before: previousPipeline,
      after: new CloudGraph({
        edges: previousPipeline.edges,
        nodes: [
          new CloudNode({
            name: 'test',
            inputs: {
              name: 'test',
              databaseSize: 'large',
              databaseType: 'postgres',
              databaseVersion: '15',
              region: 'region',
              type: 'databaseCluster',
              vpc: 'vpc',
              account: 'docker',
            },
          }),
        ],
      }),
    }, providerStore);

    assertEquals(plannedPipeline.steps.length, 1);
    assertEquals(plannedPipeline.steps[0].action, 'no-op');
  });

  it('should attempt to create node that was previously set to create but unable to', async () => {
    // If a node was set to "create" in the previous pipeline but the step never ran,
    // a subsequent pipeline should attempt to "create" the node again.

    const providerStore = new EmptyProviderStore();
    providerStore.save(new SupportedProviders.docker('docker', {}, providerStore));

    const previousStepPending = new PipelineStep({
      name: 'test',
      action: 'create',
      type: 'namespace',
      color: 'blue',
      status: { state: 'pending' },
      inputs: { type: 'namespace', account: 'test-account', name: 'test-ns' },
    });
    const previousStepErrored = new PipelineStep({
      name: 'test-2',
      action: 'create',
      type: 'namespace',
      color: 'blue',
      status: { state: 'error' },
      inputs: { type: 'namespace', account: 'test-account', name: 'test-ns-2' },
    });

    const previousPipeline = new Pipeline({ steps: [previousStepPending, previousStepErrored] });
    const plannedPipeline = await Pipeline.plan({
      before: previousPipeline,
      after: new CloudGraph({
        edges: previousPipeline.edges,
        nodes: [
          new CloudNode({
            name: 'test',
            inputs: { type: 'namespace', account: 'test-account', name: 'test-ns' },
          }),
          new CloudNode({
            name: 'test-2',
            inputs: { type: 'namespace', account: 'test-account', name: 'test-ns-2' },
          }),
        ],
      }),
    }, providerStore);

    assertEquals(plannedPipeline.steps.length, 2);
    assertEquals(plannedPipeline.steps[0].action, 'create');
    assertEquals(plannedPipeline.steps[1].action, 'create');
  });

  it('should attempt to update node that was previously set to update but unable to', async () => {
    // If a node was set to "update" in the previous pipeline but the step never ran,
    // a subsequent pipeline should attempt to "update" the node again.

    const providerStore = new EmptyProviderStore();
    providerStore.save(new SupportedProviders.docker('docker', {}, providerStore));

    const previousStep = new PipelineStep({
      name: 'test',
      action: 'update',
      type: 'namespace',
      color: 'blue',
      status: { state: 'pending' },
      inputs: { type: 'namespace', account: 'test-account', name: 'test-ns' },
    });

    const previousPipeline = new Pipeline({ steps: [previousStep] });
    const plannedPipeline = await Pipeline.plan({
      before: previousPipeline,
      after: new CloudGraph({
        edges: previousPipeline.edges,
        nodes: [
          new CloudNode({
            name: 'test',
            inputs: { type: 'namespace', account: 'test-account', name: 'test-ns' },
          }),
        ],
      }),
    }, providerStore);

    assertEquals(plannedPipeline.steps.length, 1);
    assertEquals(plannedPipeline.steps[0].action, 'update');
  });

  it('should reverse edges when removing nodes', async () => {
    const providerStore = new EmptyProviderStore();
    providerStore.save(new SupportedProviders.docker('docker', {}, providerStore));

    const stepA = createPipelineStep('stepA', 'update');
    const stepB = createPipelineStep('stepB', 'update');
    const stepC = createPipelineStep('stepC', 'create');

    const edgeAB = new CloudEdge({ from: stepA.id, to: stepB.id, required: true });
    const edgeBC = new CloudEdge({ from: stepB.id, to: stepC.id, required: false });

    const previousPipeline = new Pipeline({
      steps: [stepA, stepB, stepC],
      edges: [edgeAB, edgeBC],
    });

    const plannedPipeline = await Pipeline.plan({
      before: previousPipeline,
      after: new CloudGraph(),
    }, providerStore);

    // All steps should now be delete
    assertEquals(plannedPipeline.steps.length, 3);
    assertEquals(plannedPipeline.steps[0].action, 'delete');
    assertEquals(plannedPipeline.steps[1].action, 'delete');
    assertEquals(plannedPipeline.steps[2].action, 'delete');

    // All edges should be the reverse of the edges from the previous pipeline
    assertEquals(plannedPipeline.edges.length, 2);
    assertArrayIncludes(plannedPipeline.edges, [edgeAB.reverse(), edgeBC.reverse()]);
  });

  it('hould NOT flip edges when removing if previous pipeline steps were already delete steps', async () => {
    const providerStore = new EmptyProviderStore();
    providerStore.save(new SupportedProviders.docker('docker', {}, providerStore));

    const stepA = createPipelineStep('stepA', 'delete', 'pending');
    const stepB = createPipelineStep('stepB', 'delete', 'pending');
    const stepC = createPipelineStep('stepC', 'delete', 'pending');

    const edgeAB = new CloudEdge({ from: stepA.id, to: stepB.id, required: true });
    const edgeBC = new CloudEdge({ from: stepB.id, to: stepC.id, required: false });

    const previousPipeline = new Pipeline({
      steps: [stepA, stepB, stepC],
      edges: [edgeAB, edgeBC],
    });

    const plannedPipeline = await Pipeline.plan({
      before: previousPipeline,
      after: new CloudGraph(),
    }, providerStore);

    // All steps should still be delete
    assertEquals(plannedPipeline.steps.length, 3);
    assertEquals(plannedPipeline.steps[0].action, 'delete');
    assertEquals(plannedPipeline.steps[1].action, 'delete');
    assertEquals(plannedPipeline.steps[2].action, 'delete');

    // All edges should be exactly the same as before
    assertEquals(plannedPipeline.edges.length, 2);
    assertArrayIncludes(plannedPipeline.edges, [edgeAB, edgeBC]);
  });
});

/**
 * Helper to create a step when the actual contents of the step besides name/action/status are irrelevant.
 */
function createPipelineStep(
  name: string,
  action: StepAction,
  state?: StepStatusState,
): PipelineStep {
  return new PipelineStep({
    name,
    action,
    type: 'namespace',
    color: 'blue',
    status: { state: state || 'complete' },
    inputs: { type: 'namespace', account: 'test-account', name: 'test-ns' },
  });
}
